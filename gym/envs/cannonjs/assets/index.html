<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                margin: 0px;
                background-color: #ffffff;
                overflow: hidden;
            }
        </style>
        <script type="text/javascript" src="/js/lib/three.min.js"></script>
        <script type="text/javascript" src="/js/lib/cannon.min.js"></script>
        <script type="text/javascript" src="/js/Queue.js"></script>
    </head>
    <body>


        <script>
            var world, mass, body, shape, timeStep=1/60,
                camera, scene, renderer, geometry, material, mesh;
            var queue = new Queue;
            initThree();
            initCannon();

            function initThree() {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    1,
                    100
                );
                camera.position.z = 5;
                scene.add(camera);

                // Geometry
                geometry = new THREE.BoxBufferGeometry(2, 2, 2);
                var texture = new THREE.TextureLoader()
                    .load('textures/crate.gif');
                material = new THREE.MeshBasicMaterial( { map: texture } );
                mesh = new THREE.Mesh( geometry, material );
                scene.add(mesh);

                // Leave alone
                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor(0xffffff);
                document.body.appendChild(renderer.domElement);
                window.addEventListener('resize', onWindowResize, false);
            }

            function initCannon() {
                world = new CANNON.World();
                world.gravity.set(0, -1, 0);
                world.broadphase = new CANNON.NaiveBroadphase();
                world.solver.iterations = 10;
                shape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
                mass = 1;
                body = new CANNON.Body({
                    mass: 1,
                    linearFactor: new CANNON.Vec3(1, 0, 0)
                });
                body.addShape(shape);
                world.addBody(body);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }


            function updatePhysics() {
                // Step the physics world
                world.step(timeStep);
                // Copy coordinates from Cannon.js to Three.js
                mesh.position.copy(body.position);
                mesh.quaternion.copy(body.quaternion);
            }

            function step(action) {
                setTimeout(function(){
                    runOneStep(action);
                }, 0);
            }

            function runOneStep(action) {

                updatePhysics();
                renderer.render( scene, camera );

                // Apply force to center
                if (false) {
                    var worldPoint = new CANNON.Vec3(0, 0, 0);
                    var force = new CANNON.Vec3(100, 0, 0);
                    body.applyForce(force, worldPoint);
                }

                var canvas = document.querySelector('canvas');
                if (canvas) {
                    var ctx = canvas.getContext("webgl");
                    console.log(ctx);
                    console.log(canvas.width, canvas.height);
                    var frame = new Uint8Array(canvas.width * canvas.height * 3);
                    ctx.readPixels(0, 0, canvas.width-1, canvas.height-1, ctx.RGB, ctx.UNSIGNED_BYTE, frame);
                    console.log(frame);
                }

                var output = {
                    x: mesh.rotation.x,
                    y: mesh.rotation.y,
                    // frame: frame
                };

                queue.enqueue(output);


            }

        </script>

    </body>
</html>