<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                margin: 0px;
                background-color: #000000;
                overflow: hidden;
            }
        </style>
        <script type="text/javascript" src="/js/lib/three.min.js"></script>
        <script type="text/javascript" src="/js/lib/cannon.min.js"></script>
        <script type="text/javascript" src="/js/Queue.js"></script>
    </head>
    <body>


        <script>
            var world;
            var mass;
            var body;
            var shape;
            var timeStep = 1 / 60;
            var camera;
            var scene;
            var renderer;
            var geometry;
            var material;
            var meshes = [];
            var bodies = [];
            var iter = 0;
            var direction = 1;
            var queue = new Queue;
            // Cart Dimensions
            var cartX = 2;
            var cartY = 1;
            var cartZ = 1;

            // Pendulum Dimensions
            var pendX = 0.5;
            var pendY = 4;
            var pendZ = 0.5;

            initThree();
            initCannon();


            function initThree() {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    1,
                    100
                );
                camera.position.z = 10;
                // camera.position.x = 5;
                // camera.position.y = 5;
                // camera.lookAt(new CANNON.Vec3(0,0,0));
                scene.add(camera);

                ////////////
                // Geometry

                // Cart
                geometry = new THREE.BoxBufferGeometry(cartX, cartY, cartZ);
                var texture = new THREE.TextureLoader()
                    .load('textures/crate.gif');
                material = new THREE.MeshBasicMaterial( { map: texture } );
                cartMesh = new THREE.Mesh( geometry, material );
                scene.add(cartMesh);
                meshes.push(cartMesh);

                // Pendulum
                pendulumGeometry = new THREE.BoxBufferGeometry(pendX, pendY, pendZ);
                pendulumMesh = new THREE.Mesh( pendulumGeometry, material );
                scene.add(pendulumMesh);
                meshes.push(pendulumMesh);

                // Leave alone
                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild(renderer.domElement);
                window.addEventListener('resize', onWindowResize, false);
            }

            function initCannon() {
                world = new CANNON.World();
                world.gravity.set(0, -1, 0);
                world.broadphase = new CANNON.NaiveBroadphase();
                world.solver.iterations = 10;

                /////////
                // Bodys

                // Cart
                shape = new CANNON.Box(
                    new CANNON.Vec3(cartX / 2, cartY / 2, cartZ / 2)
                );
                cartBody = new CANNON.Body({
                    mass: 1,
                    linearFactor: new CANNON.Vec3(1, 0, 0),
                    angularFactor: new CANNON.Vec3(0, 0, 0)
                });
                cartBody.addShape(shape);
                world.addBody(cartBody);
                bodies.push(cartBody);

                // Pendulum
                pendulumShape = new CANNON.Box(
                    new CANNON.Vec3(pendX / 2, pendY / 2, pendZ / 2)
                );
                pendulumBody = new CANNON.Body({
                    mass: 1,
                    angularFactor: new CANNON.Vec3(0, 0, 1)
                });
                pendulumBody.addShape(pendulumShape);
                pendulumBody.position.set(
                    0,
                    pendY / 2 ,
                    (cartZ / 2) + (pendZ / 2)
                );
                world.addBody(pendulumBody);
                bodies.push(pendulumBody);


                ///////////////
                // Constraints

                var axis = new CANNON.Vec3(0, 0, 1);
                var p2p = new CANNON.PointToPointConstraint(
                    cartBody,
                    new CANNON.Vec3(0, 0, (cartZ / 2) + (pendZ / 2)),
                    pendulumBody,
                    new CANNON.Vec3(0, -(pendY / 2) + 0.1, -(pendZ / 2))
                );

                var hinge = new CANNON.HingeConstraint(
                    cartBody,
                    pendulumBody,
                    {
                        pivotA: new CANNON.Vec3(0, 0, 1.5), axisA: axis,
                        pivotB: new CANNON.Vec3(0, -1.4, -0.2), axisB: axis
                    }
                );
                world.addConstraint(p2p);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }


            function updatePhysics() {
                // Step the physics world
                world.step(timeStep);
                // Copy coordinates from Cannon.js to Three.js
                for (var i = 0; i < meshes.length; i++) {
                    var mesh = meshes[i];
                    var body = bodies[i];
                    mesh.position.copy(body.position);
                    mesh.quaternion.copy(body.quaternion);
                }
            }

            function step(action) {
                setTimeout(function(){
                    runOneStep(action);
                }, 0);
            }

            function runOneStep(action) {

                iter++;

                // Apply force to center
                // if (iter === 300) {
                //     var worldPoint = new CANNON.Vec3(0, 0, 0);
                //     var newtons = 100 * direction;
                //     direction *= -1;
                //     var force = new CANNON.Vec3(newtons, 0, 0);
                //     bodies[0].applyForce(force, worldPoint);
                // }

                var output = {
                    x: meshes[0].position.x
                };

                queue.enqueue(output);

                updatePhysics();
                renderer.render( scene, camera );
            }

        </script>

    </body>
</html>